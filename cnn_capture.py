# -----------------------------------------------------------------------
# cnn_capture.py
# Classification tutorial by a web camera
#
# Creation Date   : 06/Aug./2017
# Copyright (C) <2017> Hiroki Nakahara, All rights reserved.
# 
# Released under the GPL v2.0 License.
# 
# -----------------------------------------------------------------------

# -*- coding:utf-8 -*-
import cv2
import socket
import numpy as np
import time
import argparse

if __name__=="__main__":
    parser = argparse.ArgumentParser(description='Web camera demo')
    parser.add_argument('--ip', '-i', type=str, default='192.168.2.100',
                        help='IP address (Host)')
    parser.add_argument('--size', '-s', type=int, default=32,
                        help='image size to be detected by the BCNN')
    parser.add_argument('--tagfile', '-t', type=str, default='none_tag.txt',
                        help='tag file to display result')
    args = parser.parse_args()

    # load a tag file to be generated by 'gen_training_data.py'
    obj_label = []
    fname = args.tagfile
    with open(fname, 'rb') as f:
        lines = f.readlines()
        for line in lines:
            obj_label.append(line.rstrip('\n\r'))

    print("[INFO] TAGS="),
    print(obj_label)

    # set image size
    imgsize = args.size

    # Setup Socket Server
    host = args.ip #"192.168.2.100" # HOST PC IPADDRESS
    port = 10050 # PORT NUMBER

    print("[INFO] IP ADDRESS = %s" % host)
    print("[INFO] IMAGE SIZE = %dx%d" % (imgsize,imgsize))

    serversock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    serversock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    serversock.bind((host,port))
    serversock.listen(1)

    print 'Waiting for connections...'
    clientsock, client_address = serversock.accept()

    # Setup Video Camera
    capture = cv2.VideoCapture(1)
    capture.set(3, 640)
    capture.set(4, 480)
    
    if capture.isOpened() is False:
        raise("Camera IO Error")

    cv2.namedWindow("Capture", cv2.WINDOW_AUTOSIZE)

    is_auto = 0


    while True:
        ret, image = capture.read()

        if ret == False:
            continue

        cropped = image[0:480,0:480] #[y:y+h, x:x+w]
        cropped = cv2.resize( cropped, (imgsize,imgsize))

        image[0:imgsize,0:imgsize] = cropped

        key = cv2.waitKey(33) # wait 33 msec (30FPS)
        
        if is_auto == 0:
            if key == 27: # [ESC] Key
                print("ESC Key (Terminate)")
                break

            if key == 32: # [SPACE] Key
                print("Space Key (Inference a Single Image)")
                cropped = cropped.astype(np.uint8).tobytes('C')
                clientsock.send(cropped) # send image to the FPGA
            
                print("recv...")
                rcvmsg = clientsock.recv(1024) # receive from the FPGA

                idx = 0
                for c in rcvmsg:
                    print("received=%d (%s)" % (ord(c),obj_label[idx]))
                    idx += 1

            if key == 45: #[-] key
                is_auto = 1
                print("Automatically Inference")
        else:
            if key == 45: #[-] key
                is_auto = 0
                print("Stop Inference")

            start = time.time()
            cropped = cropped.astype(np.uint8).tobytes('C')
            clientsock.send(cropped)
            
            rcvmsg = clientsock.recv(1024)

            idx = 0
            for c in rcvmsg:
                if idx < 3:
                    msg = obj_label[idx] + ' = ' + str(ord(c))
                    font = cv2.FONT_HERSHEY_PLAIN
                    cv2.putText(image,msg,(10,470 - (3-idx) * 20), font, 0.8,(0,0,255))
                    cv2.line(image,(100,470 - (3-idx) * 20),(100+ord(c)*2,470 - (3-idx) * 20),(0,0,255),10)
                idx += 1

        cv2.imshow("Capture", image)

    # close socket
    clientsock.close()
    cv2.destroyAllWindows()